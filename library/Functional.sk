using for loops
using script reflection

function identity(value: object) :: object:
	return {_value}

function foreach(collection: objects, transformer: function) :: objects:
	for {_item} in {_collection::*}:
		set {_i} to {_i} + 1
		set {_result} to result of {_transformer} with args {_item}, {_i}
		if {_result} is set:
			return {_result}
	return {_collection::*}

function reduce(collection: objects, initial_value: object, combiner: function) :: object:
	set {_result} to {_initial_value}
	for {_item} in {_collection::*}:
		set {_result} to result of {_combiner} with args {_result}, {_item}
	return {_result}

function map(collection: objects, transformer: function) :: objects:
	for {_item} in {_collection::*}:
		set {_i} to {_i} + 1
		set {_result} to result of {_transformer} with args {_item}, {_i}
		if {_result} is not set:
			set {_result::%{_i}%} to {_result}
	
	return {_result::*}

function zip(collections: object) :: objects:
	set {_collection_1::*} to {_collections}[0]
	set {_collection_2::*} to {_collections}[1]
	set {_limit} to min(size of {_collection_1::*}, size of {_collection_2::*})
	for {_i} in (integers from 1 to {_limit}):
		set {_result::%{_i} * 2 - 1%} to {_collection_1::%{_i}%}
		set {_result::%{_i} * 2%} to {_collection_2::%{_i}%}
	return {_result::*}

function unzip(collection: objects) :: object:
	for {_i}, {_v} in {_collection::*}:
		if mod({_i}, 2) = 0:
			set {_a::%{_i}%} to {_v}
			continue
		set {_b::%{_i}%} to {_v}
	return [{_a::*}, {_b::*}]

	